"use strict";
/**
 * @module Core
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
/*
 * japa
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
const Contracts_1 = require("../Contracts");
const Emitter_1 = require("../Emitter");
/**
 * Runner class is used for defining global properties
 * and run all the tests inside the group.
 */
class Runner {
    constructor(_groups, _options) {
        this._groups = _groups;
        this._options = _options;
    }
    /**
     * Returns a boolean telling if any of the groups or it's tests
     * has errors.
     */
    get hasErrors() {
        return !!this._groups.find((group) => group.hasErrors);
    }
    /**
     * Define a set of test groups to use
     */
    useGroups(groups) {
        this._groups = groups;
        return this;
    }
    /**
     * Define custom reporter
     */
    reporter(fn) {
        if (typeof (fn) !== 'function') {
            throw new Error('"runner.reporter" expects callback to be a valid function');
        }
        this._reporterFn = fn;
        return this;
    }
    /**
     * Run all the tests inside the registered groups
     */
    async run() {
        if (typeof (this._reporterFn) !== 'function') {
            throw new Error('Make sure to define tests reporter as a function');
        }
        /**
         * Give emitter instance to the reporter
         */
        this._reporterFn(Emitter_1.emitter, this._options);
        /**
         * Emit the started event
         */
        Emitter_1.emitter.emit(Contracts_1.IEvents.STARTED);
        /**
         * Run all the tests
         */
        for (let group of this._groups) {
            await group.run();
            /**
             * Break when bail is true and group has errors
             */
            if (this._options.bail && group.hasErrors) {
                break;
            }
        }
        /**
         * Emit completed event
         */
        Emitter_1.emitter.emit(Contracts_1.IEvents.COMPLETED);
    }
}
exports.Runner = Runner;
